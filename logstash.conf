# Read input from filebeat by listening to port 5044 on which filebeat will send the data
# input {
#     beats {
# 	    type => "test"
#         port => "5044"
#     }
# }
 
filter {
  mutate {
    add_field => { "acx_filter_version" => "6.8.14" }
  }
  if [source] == "/aconex/logs/babylon.log" {
    if "timestamp=" in [message] {
      grok { 
        match => { "message" => "timestamp=%{GREEDYDATA:message_time_stamp}\|level=%{LOGLEVEL:log_level}\|logger=%{DATA:logger}\|tid=%{DATA:thread_id}\|rid=(%{DATA:request_id})?\|rgi=(%{DATA:request_group_id})?\|uid=(%{NUMBER:user_id:int})?\|pid=(%{NUMBER:project_id:int})?\|orgid=(%{NUMBER:org_id:int})?\|iuid=(%{DATA:iuid})?\|clientName=(%{DATA:client_name})?\|ip=(%{IP:ip_address})?\|message=%{GREEDYDATA:log_message}" } 
      }
    } else {
      grok { 
        match => { "message" => "^\[%{GREEDYDATA:message_time_stamp} %{LOGLEVEL:log_level}( |)?\]\[%{DATA:logger}\]\[tid=%{GREEDYDATA:thread_id},rid=%{GREEDYDATA:request_id},rgi=%{GREEDYDATA:request_group_id},ip=(%{IP:ip_address})?,uid=(%{NUMBER:user_id:int})?,pid=(%{NUMBER:project_id:int})?\] \|\| %{GREEDYDATA:log_message}" } 
      }
    }
  }
  if [fields][source] == "babylon" {
    if "timing.LoggerSink" in [message] {
      mutate {
        add_tag => [ "babylon-metrics" ]
      }
      if "By, total" in [message] {
        grok { 
          match => { "message" => "(\|\| %{DATA}\t|message\=Top\t)(%{WORD:controller})?(:|\t)(%{WORD:action})?\t%{GREEDYDATA}Elapsed time: own %{BASE16FLOAT:elapsed_time_own} ms, total %{BASE16FLOAT:elapsed_time_total} ms\tTotal CPU: own %{BASE16FLOAT:cpu_own} ms, total %{BASE16FLOAT:cpu_total} ms\tUser CPU: own %{BASE16FLOAT:user_cpu_own} ms, total %{BASE16FLOAT:user_cpu_total} ms\tSystem CPU: own %{NUMBER:system_cpu_own:float} ms, total %{NUMBER:system_cpu_total:float} ms\tHeap Bytes: own %{BASE16FLOAT:heap_bytes_own} By, total %{BASE16FLOAT:heap_bytes_total} By\tBlocked count: own %{NUMBER:blocked_count_own:int}, total %{NUMBER:blocked_count_total:int}\tBlocked time: own %{NUMBER:blocked_timet_own:int} ms, total %{NUMBER:blocked_time_total:int} ms\tWait count: own %{NUMBER:wait_count_own:int}, total %{NUMBER:wait_count_total:int}\tWait time: own %{NUMBER:wait_time_own:int} ms, total %{NUMBER:wait_time_total:int} ms\tDB time: own %{NUMBER:db_time_own:int} ms, total %{NUMBER:db_time_total:int} ms\tDB count: own %{NUMBER:db_count_own:int}, total %{NUMBER:db_count_total:int}\tDB lread: own %{NUMBER:db_lread_own:int}, total %{NUMBER:db_lread_total:int}\tDB pread: own %{NUMBER:db_pread_own:int}, total %{NUMBER:db_pread_total:int}\tDB CPU time: own %{NUMBER:cpu_time_own:int} ms, total %{NUMBER:cpu_time_total:int} ms\tDB in bytes: own %{NUMBER:db_in_bytes_own:int} By, total %{NUMBER:db_in_bytes_total:int} By\tDB out bytes: own %{NUMBER:db_out_bytes_own:int} By, total %{NUMBER:db_out_bytes_total:int} By" } 
        }
      } else if "byte, total" in [message] {
        grok { 
          match => { "message" => "(\|\| %{DATA}\t|message\=Top\t)(%{WORD:controller})?(:|\t)(%{WORD:action})?\t%{GREEDYDATA}Elapsed time: own %{BASE16FLOAT:elapsed_time_own} ms, total %{BASE16FLOAT:elapsed_time_total} ms\tTotal CPU: own %{BASE16FLOAT:cpu_own} ms, total %{BASE16FLOAT:cpu_total} ms\tUser CPU: own %{BASE16FLOAT:user_cpu_own} ms, total %{BASE16FLOAT:user_cpu_total} ms\tSystem CPU: own %{NUMBER:system_cpu_own:float} ms, total %{NUMBER:system_cpu_total:float} ms\tHeap Bytes: own %{BASE16FLOAT:heap_bytes_own} byte, total %{BASE16FLOAT:heap_bytes_total} byte\tBlocked count: own %{NUMBER:blocked_count_own:int} one, total %{NUMBER:blocked_count_total:int} one\tBlocked time: own %{NUMBER:blocked_timet_own:int} ms, total %{NUMBER:blocked_time_total:int} ms\tWait count: own %{NUMBER:wait_count_own:int} one, total %{NUMBER:wait_count_total:int} one\tWait time: own %{NUMBER:wait_time_own:int} ms, total %{NUMBER:wait_time_total:int} ms\tDB time: own %{NUMBER:db_time_own:int} ms, total %{NUMBER:db_time_total:int} ms\tDB count: own %{NUMBER:db_count_own:int} one, total %{NUMBER:db_count_total:int} one\tDB lread: own %{NUMBER:db_lread_own:int} one, total %{NUMBER:db_lread_total:int} one\tDB pread: own %{NUMBER:db_pread_own:int} one, total %{NUMBER:db_pread_total:int} one\tDB CPU time: own %{NUMBER:cpu_time_own:int} ms, total %{NUMBER:cpu_time_total:int} ms\tDB in bytes: own %{BASE16FLOAT:db_in_bytes_own} byte, total %{BASE16FLOAT:db_in_bytes_total} byte\tDB out bytes: own %{BASE16FLOAT:db_out_bytes_own} byte, total %{BASE16FLOAT:db_out_bytes_total} byte" } 
        }
      }

      if [controller] =~ /(?i)search/ {
        mutate {
          add_field => { "controller_type" => "search" }
        }
      }
      else if [controller] =~ /(?i)mail/ {
        mutate {
          add_field => { "controller_type" => "mail" }
        }
      }
      else if [controller] =~ /(?i)transmittal/ {
        mutate {
          add_field => { "controller_type" => "transmittal" }
        }
      }
      else if [controller] =~ /(?i)directory/ {
        mutate {
          add_field => { "controller_type" => "directory" }
        }
      }
      else if [controller] =~ /(?i)logon/ {
        mutate {
          add_field => { "controller_type" => "logon" }
        }
      }
      else if [controller] =~ /(?i)task/ {
        mutate {
          add_field => { "controller_type" => "task" }
        }
      }
      else if [controller] =~ /(?i)bim/ {
        mutate {
          add_field => { "controller_type" => "bim" }
        }
      }
      else if [controller] =~ /(?i)user/ {
        mutate {
          add_field => { "controller_type" => "user" }
        }
      }
      else if [controller] =~ /(?i)ping/ {
        mutate {
          add_field => { "controller_type" => "ping" }
        }
      }
      else if [controller] =~ /(?i)oauth/ {
        mutate {
          add_field => { "controller_type" => "oauth" }
        }
      }
      else if [controller] =~ /(?i)download/ {
        mutate {
          add_field => { "controller_type" => "download" }
        }
      }
      else if [controller] =~ /(?i)asset/ {
        mutate {
          add_field => { "controller_type" => "asset" }
        }
      }
      else if [controller] =~ /(?i)upload/ {
        mutate {
          add_field => { "controller_type" => "upload" }
        }
      }
      else if [controller] =~ /(?i)document/ {
        mutate {
          add_field => { "controller_type" => "document" }
        }
      }
      else if [controller] =~ /(?i)correspondence/ {
        mutate {
          add_field => { "controller_type" => "correspondence" }
        }
      }
      else if [controller] =~ /(?i)admin/ {
        mutate {
          add_field => { "controller_type" => "admin" }
        }
      }
      else if [controller] =~ /(?i)nav/ {
        mutate {
          add_field => { "controller_type" => "nav" }
        }
      }
      else if [controller] =~ /(?i)speed/ {
        mutate {
          add_field => { "controller_type" => "speed" }
        }
      }
      else if [controller] =~ /(?i)notice/ {
        mutate {
          add_field => { "controller_type" => "notice" }
        }
      }
      else if [controller] =~ /(?i)workflow/ {
        mutate {
          add_field => { "controller_type" => "workflow" }
        }
      }
      else if [controller] =~ /(?i)ControlledDoc/ {
        mutate {
          add_field => { "controller_type" => "ControlledDoc" }
        }
      }
      else if [controller] =~ /(?i)Manifestimport/ {
        mutate {
          add_field => { "controller_type" => "Manifestimport" }
        }
      }
      else if [controller] =~ /(?i)FeatureSwitch/ {
        mutate {
          add_field => { "controller_type" => "FeatureSwitch" }
        }
      }
      else if [controller] =~ /(?i)tender/ {
        mutate {
          add_field => { "controller_type" => "tender" }
        }
      }
      else if [controller] =~ /(?i)package/ {
        mutate {
          add_field => { "controller_type" => "package" }
        }
      }
      else if [controller] =~ /(?i)print/ {
        mutate {
          add_field => { "controller_type" => "print" }
        }
      }
      else {
        mutate {
          add_field => { "controller_type" => "other" }
        }
      }
    }
    else if "ERROR" in [message] {
      mutate {
        add_tag => [ "babylon-errors" ]
      }
      if "Exception" in [log_message] {
        grok { 
          match => { "message" => "(\n|\|\| )%{DATA:exception_type}Exception" } 
        }
      }
      if "JmsBackedNotificationDataQueue" in [message] and "Corrupted payload found" in [message] {
        mutate {
          add_field => { "error_type" => "corrupted_json_notifications" }
        }
      }
      else if "An attempt by a client to checkout a Connection has timed out" in [message] {
        mutate {
          add_field => { "error_type" => "db_connection_timeout" }
        }
      }
      else if "at java.lang.Thread.run" in [message] and "Connection has timed out" in [message] {
        mutate {
          add_field => { "error_type" => "java_connection_timeout" }
        }
      }
    }
    else if "Multi file upload" in [message] or "schedule: started" in [message] or "Starting Zip download" in [message] or "About to export" in [message] or "transmittal registration jobs" in [message] or "Reindex of correspondence for user" in [message] or "Failed to create IndexSearcher" in [message] or "api.RemoteSearch" in [message] or "transmittal]" in [message] or "nsmittalRegistration]" in [message] or "csrfToken created" in [message] or "Remote vs Local" in [message] or "Logged out by time out page redirection for userId" in [message] or "Session created" in [message] or "buildUserSession" in [message] {
      mutate {
        add_tag => [ "babylon-other" ]
      }
      if "Multi file upload" in [message] {
        if "schedule: time taken" in [message] {
          grok { 
            match => { "message" => "schedule: time taken\] :  \[%{NUMBER:time_taken:int}\]" } 
          }
        } else {
          grok { 
            match => { "message" => "qqtotalfilesize='%{NUMBER:file_bytes:float}', qqfilename='%{DATA:file_name}', location='%{DATA:file_location}', qquuid='%{DATA:file_uuid}', documentImportId=%{NUMBER:doc_import_id:int}}" } 
          }
        }
        mutate {
          add_field => { "babylon_other_type" => "multi_file_upload" }
        }
        if [file_bytes] {
          ruby {
            code => "event.set('fileGB',(event.get('file_bytes')/(1024 * 1024 * 1024 )).round(6))"
          }
          ruby {
            code => "event.set('fileMB',(event.get('file_bytes')/(1024 * 1024 )).round(6))"
          }
        }
      }
      else if "About to export" in [message] {
        grok {
          match => { "message" => "About to export %{NUMBER:item_count:int} %{WORD:item_type} items to excel, %{DATA}\[rowLimit:%{NUMBER:rows_count:int}\],\[retrievalBatchLimit:%{NUMBER:retrieval_batch_limit:int}\]"}
        }
        if "[orgId:" in [message] {
          grok {
            match => { "message" => "\[orgId:%{NUMBER:org_id:int}\]"}
          }
        }
        mutate {
          add_field => { "babylon_other_type" => "about_to_export" }
        }
      }
      else if "Starting Zip download" in [message] {
        grok {
          match => { "message" => "\[no of documents: %{NUMBER:doc_count:int}\]"}
        }
        mutate {
          add_field => { "babylon_other_type" => "start_zip_download" }
        }
      }
      else if "transmittal registration jobs" in [message] {
        grok {
          match => { "message" => "Creating \[%{NUMBER:transmittal_regis_job_count:int}\] transmittal registration jobs \(\[%{NUMBER:transmittal_uniq_orgs_count:int}\] unique orgs\) for correspondence \[%{NUMBER:correspondence_id:int}\]"}
        }
      }
      else if "monitor.transmittal]" in [message] {
        if "timeTaken (ms)=" in [log_message] {
          grok {
            match => { "message" => "timeTaken \(ms\)= %{NUMBER:transmittal_time_taken:int}"}
          }
        }
        if "TimeTaken (ms)=" in [log_message] {
          grok {
            match => { "message" => "TimeTaken \(ms\)= %{NUMBER:transmittal_time_taken:int}"}
          }
        }
        if "org=" in [log_message] {
          grok {
            match => { "message" => "org=%{NUMBER:org_id:int},"}
          }
        }
        if "[org:" in [log_message] {
          grok {
            match => { "message" => "\[org:%{DATA:organization_id}\]"}
          }
        }
        if "Number of CDs" in [log_message] {
          grok {
            match => { "message" => "Number of CDs: %{NUMBER:number_of_cd:int}"}
          }
        }
        if "size=" in [log_message] {
          grok {
            match => { "message" => "size=%{NUMBER:size:int}"}
          }
        }
      }
      else if "[nsmittalRegistration]" in [message] {
        if "Notification requested for transmittal" in [message] {
          grok {
            match => { "message" => "correlationId=%{DATA:correlation_id},correspondenceId=(%{NUMBER:correspondence_id:int})?,docId=(%{NUMBER:doc_id:int})?,oId=(%{NUMBER:oid:int})?,pId=(%{NUMBER:pid:int})?,totalTime=(%{NUMBER:transmittal_regis_time:int})?"}                
          }
          mutate {
            add_field => { "transmittal_type" => "notification_requested" }
          }
        }
        else if "Indexing requested for transmittal" in [message] {
          grok {
            match => { "message" => "correlationId=%{DATA:correlation_id},correspondenceId=(%{NUMBER:correspondence_id:int})?,docId=(%{NUMBER:doc_id:int})?,oId=(%{NUMBER:oid:int})?,pId=(%{NUMBER:pid:int})?"}
          }
          mutate {
            add_field => { "transmittal_type" => "indexing_requested" }
          }
        }
        else if "Creating transmittal registration job" in [message] {
          grok {
            match => { "message" => "correlationId=%{DATA:correlation_id},correspondenceId=(%{NUMBER:correspondence_id:int})?,oId=(%{NUMBER:oid:int})?,docId=(%{NUMBER:doc_id:int})?,pId=(%{NUMBER:pid:int})?"}
          }
          mutate {
            add_field => { "transmittal_type" => "creating_job" }
          }
        }
      }
      else if "Remote vs Local" in [message] {
        grok {
          match => { "message" => "Remote vs Local: %{NUMBER:remote_count:int} vs %{NUMBER:local_count:int}, connectTime=%{NUMBER:connect_time:int}, overhead=%{NUMBER:overhead_count:int}, #entities=%{NUMBER:entities:int}, #bytes transferred=%{NUMBER:bytes_transferred:int}"}
        }
        mutate {
          add_field => { "babylon_other_type" => "remote_vs_local" }
        }
      }        
    }
  }
  else if [fields][source] == "babylon-security" {
    if "timestamp=" in [message] {
      grok { 
        match => { "message" => "timestamp=%{GREEDYDATA:message_time_stamp}\|level=%{LOGLEVEL:log_level}\|tid=%{DATA:thread_id}\|rid=(%{DATA:request_id})?\|rgi=(%{DATA:request_group_id})?\|clientName=(%{DATA:client_name})?\|ip=(%{IP:ip_address})?\|audit=AUDIT: module=%{DATA:module}\|uid=(%{NUMBER:user_id:int})?\|pid=(%{NUMBER:project_id:int})?\|message=eventType=%{DATA:event_type}, %{GREEDYDATA:log_message}" } 
      }
    } else {
      grok { 
        match => { "message" => "^\[%{TIMESTAMP_ISO8601:message_time_stamp} %{LOGLEVEL:log_level} \]%{GREEDYDATA}\[tid=(%{GREEDYDATA:thread_id})?,rid=(%{GREEDYDATA:request_id})?\]\[oid=(%{GREEDYDATA:oid})?\]\[clientName=(%{DATA:client_name})?\]\[ip=(%{IP:ip})?\] :AUDIT: module=(%{WORD:module})?, requestUserId=(%{NUMBER:request_user_id})?, requestProjectId=(%{NUMBER:request_project_id})?, eventType=%{DATA:event_type}, (%{GREEDYDATA:rest_of_message})?" } 
      }
    }
  }
  else if [fields][source] == "babylon-api" {
    grok {
      match => { "message" => "^\[%{TIMESTAMP_ISO8601:message_time_stamp} %{LOGLEVEL:log_level}( )?\]\[(%{DATA:logger})?\]\[(%{DATA:thread_id})? (%{DATA:request_id})? (%{DATA:request_group})?\]\[(%{IP:ip_address})?\]\[(%{NUMBER:impersonating_user_id:int})?\]\[(%{NUMBER:user_id:int})?\]\[(%{DATA:client_name})?\]"}                
    }
    if "consecutive failure attempts" in [message] {
      grok {
        match => { "message" => "validate user \(%{NUMBER:user_id:int}\) result \(\[credentials=%{GREEDYDATA:credentials},account status=%{GREEDYDATA:account_status},consecutive failure attempts=%{NUMBER:consecutive_failure_attempts:int}\]\)"}                
      }
    } else if "Inbound Message" in [message] {
      grok {
        match => { "message" => "ID: %{NUMBER:inbound_message_id}\nAddress: %{DATA:address}\nEncoding: %{DATA:encoding}\nContent-Type:%{DATA:content_type}\nHeaders: \{%{DATA:headers}\}"}                
      }
      if [headers] {
        kv {
          source => "headers"
          field_split_pattern => ", "
          remove_char_key => "\{\},"
          remove_char_value => "\[\]\{\}"
        }
      }
    }
    if "project id" in [message] {
      grok {
        match => { "message" => "project id %{NUMBER:project_id:int}"}                
      }
    }
    if "correspondence id" in [message] {
      grok {
        match => { "message" => "correspondence id %{NUMBER:correspondence_id:int}"}                
      }
    }
    if [log_level]== "ERROR" and "Exception" in [message] {
      grok { 
        match => { "message" => "(\n|\|\| )%{DATA:exception_type}Exception" } 
      }
    }
  }
  else if [fields][source] == "babylon-emailer" {
    grok {
        match => { "message" => '^\[%{TIMESTAMP_ISO8601:message_time_stamp} %{LOGLEVEL:log_level}?( |)\]'}                
      }
    if "SimpleMailSender" in [message] {
      grok {
        match => { "message" => '"messageId":"<%{DATA:message_id}>", "buildTime":"%{NUMBER:build_time:int}", "sendTime":"%{NUMBER:send_time:int}", "attachmentCount":"%{NUMBER:attachment_count:int}"}'}                
      }
    }
    else if "ificationDataHandler" in [message] {
      grok {
        match => { "message" => 'envelopeVersion":"%{NUMBER:envelope_version:int}", "notificationType":"%{WORD:notification_type}", "version":"%{NUMBER:sent_mail_version:int}"}'}
      }
    }
    else if "Execution of JMS message listener failed" in [message] {
      mutate {
        add_field => { "emailer_error" => "jms_failed" }
      }
    }
  }
  else if [fields][source] == "babylon-gc" {
    grok {
      match => { "message" => '^%{TIMESTAMP_ISO8601:timestamp}: %{NUMBER:jvm_time}: \[%{DATA:gc_type} \(%{DATA:gc_cause}\)%{DATA}\[%{WORD:gc_collector}: %{NUMBER:young_generation_before:int}K\-\>%{NUMBER:young_generation_after:int}K\(%{NUMBER:young_generation_capacity:int}K\)\] %{NUMBER:heap_before:int}K\-\>%{NUMBER:heap_after:int}K\(%{NUMBER:heap_capacity:int}K\), %{NUMBER:collection_time:float} secs\] \[Times: user=%{NUMBER:cpu_time:float} sys=%{NUMBER:system_time:float}, real=%{NUMBER:clock_time:float} secs\]'}
    }
  }
  else if [fields][source] == "babylon-startup" {
    grok {
      match => { "message" => '^%{TIMESTAMP_ISO8601:message_time_stamp}(:%{LOGLEVEL:log_level}::%{DATA:module}:)?%{GREEDYDATA:log_message}?'}
    }
  }
  else if [fields][source] == "babylon-fileupload" {
    if "stitchpool" in [message] {
      grok {
        match => { "message" => "^%{LOGLEVEL:log_level}%{DATA}\[%{DATA:thread_id}\]\[%{DATA:logger}\]\[%{DATA:message_time_stamp}\]%{GREEDYDATA}\] -(  | )?%{GREEDYDATA:log_message}"}
      }
    } else {
      grok {
        match => { "message" => '^%{LOGLEVEL:log_level}%{DATA}\[%{DATA:thread_id} - %{WORD:http_method} \/file-upload\/projects\/%{NUMBER:project_id:int}\/users\/%{NUMBER:user_id:int}(\/%{DATA:file_type})?\]\[%{DATA:logger}\]\[%{DATA:message_time_stamp}\]\[%{DATA:request_id}\]\[(%{NUMBER:project_id:int})?\]%{DATA}\[(%{NUMBER:user_id:int})?\] -(  | )?%{GREEDYDATA:log_message} Mozilla'}
      }
    }
    if "{" in [log_message] {
      grok {
        match => { "message" => '-(  | )?%{DATA:action}\{%{DATA:params}\}'}
      }
      kv {
        source => "params"
        field_split_pattern => ", "
      }
      if [fileSize] != "null" {
        mutate {
          convert => ["fileSize", "integer"]
        }
      }
      if [currentPartIndex] != "null" {
        mutate {
          convert => ["currentPartIndex", "integer"]
        }
      }
      if [totalParts] != "null" {
        mutate {
          convert => ["totalParts", "integer"]
        }
      }
    }
    if "(Complete)" in [log_message] {
      grok {
        match => { "message" => '- %{NUMBER:http_status_code}  \(Complete\)'}
      }
    }
    if "action=" in [log_message] {
      kv {
        source => "log_message"
        field_split_pattern => ", "
      }
      if [currentPartIndex] != "null" {
        mutate {
          convert => ["currentPartIndex", "integer"]
        }
      }
    }
  }
  else if [fields][source] == "babylon-fileupload-audit" {
    grok {
      match => { "message" => '^\[%{GREEDYDATA:message_time_stamp} %{LOGLEVEL:log_level}( |)?\]\[tid=(%{DATA:thread_id})? - %{WORD:http_method} \/file-upload\/projects\/%{NUMBER:project_id:int}\/users\/%{NUMBER:user_id:int}(\/%{DATA:file_type})?,rid=(%{DATA:request_id})?\]\[oid=(%{NUMBER:org_id:int})?\]\[clientName=(%{DATA:client_name})?\]\[ip=(%{IP:ip_address})?\] :AUDIT: %{GREEDYDATA:params}'}
    }
    if [params] {
      kv {
        source => "params"
        field_split_pattern => ", "
      }
      if [totalPartsOfFile] != "null" {
        mutate {
          convert => ["totalPartsOfFile", "integer"]
        }
      }
      if [currentPartIndex] != "null" {
        mutate {
          convert => ["currentPartIndex", "integer"]
        }
      }
    }
  }
  else if [fields][source] == "babylon-fileupload-access" {
    grok {
      match => { "message" => '(%{IP:ip_address})?%{DATA}\[%{GREEDYDATA:message_time_stamp}\] "%{WORD:http_method} %{DATA:http_endpoint} %{DATA:http_protocol}" %{NUMBER:http_status_code} %{NUMBER:response_length:int} "%{DATA:http_url}" %{NUMBER:response_time_ms:int}'}
    }
    if [http_method] == "POST" {
      grok {
        match => { "message" => '\/file-upload\/projects\/%{NUMBER:project_id:int}\/users\/%{NUMBER:user_id:int}(\/%{DATA:file_type})? '}
      }
    }
    if "documentImportId" in [http_url] {
      grok {
        match => { "message" => "documentImportId=%{NUMBER:document_import_id}&"}
      }
    }
  }
  else if [fields][source] == "httpd-logs" {
    grok {
      match => { "message" => '^%{TIMESTAMP_ISO8601:message_time_stamp} %{GREEDYDATA:collector} httpd'}
    }
    if "SelectList" in [message] {
      grok {
        match => { "message" => 'search_type=%{DATA:search_type}&search_result_size=%{NUMBER:search_result_size}&sort_field=%{DATA:sort_field}&sort_direction=%{DATA:sort_direction}&show_document_history=%{DATA:show_doc_history} HTTP'}
      }
    } else if "time_uS=" in [message] {
      grok {
        match => { "message" => 'time_uS=%{NUMBER:response_time_micros:int} bytes=(-|%{NUMBER:bytes:float}) status=%{NUMBER:http_status_code} origin=?(%{IP:ip1}|%{IP:ip1}, %{IP:ip2}|%{IP:ip1}, %{IP:ip2}, %{IP:ip3}|%{IP:ip1}, %{IP:ip2}, %{IP:ip3}, %{IP:ip4}|%{IP:ip1}, %{IP:ip2}, %{IP:ip3}, %{IP:ip4}, %{IP:ip5}|%{IP:ip1}, %{IP:ip2}, %{IP:ip3}, %{IP:ip4}, %{IP:ip5}, %{IP:ip6}|-) api=%{DATA:api_key} request_group=%{DATA:request_group} route_info=%{DATA:route_info} worker=%{DATA:worker_address} route_changed=%{DATA:route_changed} jasper_session_id=%{DATA:jasper_session_id} X-Unique-Id=%{GREEDYDATA:x_unique_id} \"%{WORD:method} %{GREEDYDATA:url}'}
      }
    }
    if [ip2] {
      geoip {
        source => "ip2"
      }
    }
    if [bytes] {
      ruby {
        code => "event.set('GB',(event.get('bytes')/(1024 * 1024 * 1024)).round(6))"
      }
      ruby {
        code => "event.set('MB',(event.get('bytes')/(1024 * 1024)).round(6))"
      }
    }
    if "&page_size=" in [message] {
      grok {
        match => { "message" => "&page_size=%{NUMBER:page_size:int}"}
      }
    }
    if "search_type=FULL" in [message] {
      mutate {
        add_field => { "search_type" => "full" }
      }
    }
    if "search_type=PAGED" in [message] {
      mutate {
        add_field => { "search_type" => "paged" }
      }
    }
    if [message] =~ /(?i)mobile/ {
      mutate {
        add_field => { "httpd_type" => "mobile" }
      }
    }
    else if [message] =~ /(?i)mail/ {
      mutate {
        add_field => { "httpd_type" => "mail" }
      }
    }
    else if [message] =~ /(?i)login/ {
      mutate {
        add_field => { "httpd_type" => "login" }
      }
    }
    else if "/FileDownload" in [message] {
      mutate {
        add_field => { "httpd_type" => "file_download" }
      }
      if "accessReason" in [message] {
        grok {
          match => { "message" => 'accessReason=%{WORD:access_reason}( |&)?'}
        }
      }
    }
    else if [message] =~ /(?i)download/ {
      mutate {
        add_field => { "httpd_type" => "download" }
      }
    }
    else if [message] =~ /(?i)upload/ {
      mutate {
        add_field => { "httpd_type" => "upload" }
      }
    }
    else if [message] =~ /(?i)documents/ {
      mutate {
        add_field => { "httpd_type" => "documents" }
      }
    }
    else if [message] =~ /(?i)session/ {
      mutate {
        add_field => { "httpd_type" => "session" }
      }
    }
    else if "/api/" in [message] {
      mutate {
        add_field => { "httpd_type" => "api" }
      }
    }
  }
  else if [fields][source] == "jobrunner" {
    if "ERROR" in [message] {
      mutate {
        add_tag => [ "jobrunner-errors" ]
      }
    }
    else if [message] =~ /.*About to export .* items to excel.*/ {
      grok {
        match => { "message" => 'About to export %{NUMBER:item_count:int} %{WORD:item_type} items to excel, \[orgId:%{NUMBER:org_id:int}\],\[rowLimit:%{NUMBER:rows_count:int}\],\[retrievalBatchLimit:%{NUMBER:retrieval_batch_limit:int}\]'}
      }
      mutate {
        add_tag => [ "jobrunner-other" ]
      }
    }
    else if "Writing a new Excel worksheet" in [message] {
      grok {
        match => { "message" => 'Writing a new Excel worksheet \[orgId:%{NUMBER:org_id:int}\],\[fileName:/nas/%{WORD:instance_legacy_name}/filestore%{NUMBER:file_store_id:int}%{DATA}\[NoOfRows:%{NUMBER:row_count:int}\]'}
      }
      mutate {
        add_tag => [ "jobrunner-other" ]
      }
    }
    else if [message] =~ /.*Exported .* items .*/ {
      grok {
        match => { "message" => 'Exported %{NUMBER:item_count:int} items \[%{NUMBER:completed_percentage:int}% done\],\[orgId:%{NUMBER:org_id:int}\],\[timeTaken:%{NUMBER:time_taken:int}\]'}
      }
      mutate {
        add_tag => [ "jobrunner-other" ]
      }
    }
    else if "Export to excel completed" in [message] {
      grok {
        match => { "message" => 'Export to excel completed \[orgId:%{NUMBER:org_id:int}\],\[Rows:%{NUMBER:rows_count:int}\],\[totalItems:%{NUMBER:total_items:int}\],\[usedMemBytes:%{NUMBER:used_mem_bytes:float}\],\[dbTime:%{NUMBER:db_time:int}\],\[totalTimeTaken:%{NUMBER:time_taken:int}\]'}
      }
      mutate {
        add_tag => [ "jobrunner-other" ]
      }
      if [used_mem_bytes] {
        ruby {
          code => "event.set('used_mem_GB',(event.get('used_mem_bytes')/(1024 * 1024 * 1024 )).round(5))"
        }
        ruby {
          code => "event.set('used_mem_MB',(event.get('used_mem_bytes')/(1024 * 1024 )).round(5))"
        }
      }
    }
  }
  else if [fields][source] == "babylon-scheduler" {
    grok {
      match => { "message" => '\[%{DATA:message_time_stamp} %{LOGLEVEL:log_level}( |)?\]\[%{DATA:logger}\]\[%{DATA:cron_task_worker}\]'}
    }
    if "Scheduled Task execution completed" in [message] {
      mutate {
        add_field => { "task_execution_status" => "completed" }
      }
      grok {
        match => { "message" => 'jobRunTime: %{NUMBER:job_run_time:int} ms'}
      } 
    }
    else if "An existing scheduler task with the same name (Copy Document Relationship Task) is already running, skipping execution" in [message] {
      mutate {
        add_field => { "task_execution_status" => "skipped" }
      }
    }
    else if "Scheduled Task execution about to start" in [message] {
      mutate {
        add_field => { "task_execution_status" => "starting" }
      }
    }
  }
  else if [fields][source] == "indexer-gc" {
    if "GC pause" in [message] {
      grok {
        match => { "message" => '^%{TIMESTAMP_ISO8601:message_time_stamp}: %{NUMBER:jvm_time:float}: \[%{DATA:gc_type} \(%{DATA:gc_cause}\) \(%{DATA:heap_memory_type}\)%{DATA}\[Eden: %{NUMBER:eden_before:float}(G|M|B)?\(%{NUMBER:eden_capacity_before:float}(G|M|B)?\)\-\>%{NUMBER:eden_after:float}B\(%{NUMBER:eden_capacity_after:float}(G|M|B)?\) Survivors: %{NUMBER:survivors_before:float}(G|M|B)?\-\>%{NUMBER:survivors_after:float}(G|M|B)? Heap: %{NUMBER:heap_before:float}(G|M|B)?\(%{NUMBER:heap_capacity_before:float}(G|M|B)?\)->%{NUMBER:heap_after:float}(G|M|B)?\(%{NUMBER:heap_capacity_after:float}(G|M|B)?\)\]%{DATA}\[Times: user=%{NUMBER:cpu_time:float} sys=%{NUMBER:system_time:float}, real=%{NUMBER:clock_time:float} secs\]'}
      } 
    }
    else if "GC cleanup" in [message] {
      grok {
        match => { "message" => '^%{TIMESTAMP_ISO8601:message_time_stamp}: %{NUMBER:jvm_time:float}: \[%{DATA:gc_type} %{NUMBER:heap_before:float}(G|M|B)?->%{NUMBER:heap_after:float}(G|M|B)?\(%{NUMBER:heap_capacity:float}(G|M|B)?\), %{NUMBER} secs\]%{DATA}\[Times: user=%{NUMBER:cpu_time:float} sys=%{NUMBER:system_time:float}, real=%{NUMBER:clock_time:float} secs\]'}
      } 
    }
    else if "GC remark" in [message] {
      grok {
        match => { "message" => '^%{TIMESTAMP_ISO8601:message_time_stamp}: %{NUMBER:jvm_time:float}: \[%{DATA:gc_type} %{TIMESTAMP_ISO8601}%{GREEDYDATA}\[Times: user=%{NUMBER:cpu_time:float} sys=%{NUMBER:system_time:float}, real=%{NUMBER:clock_time:float} secs\]'}
      } 
    }
  }
  else if [fields][source] == "indexer" {
    if [logger] == "it.timing.LoggerSink" {
      if "By, total" in [message] {
        grok { 
          match => { "message" => "(\|\| %{DATA}\t|message\=Top\t)(%{WORD:controller})?(:|\t)(%{WORD:action})?\t%{GREEDYDATA}Elapsed time: own %{BASE16FLOAT:elapsed_time_own} ms, total %{BASE16FLOAT:elapsed_time_total} ms\tTotal CPU: own %{BASE16FLOAT:cpu_own} ms, total %{BASE16FLOAT:cpu_total} ms\tUser CPU: own %{BASE16FLOAT:user_cpu_own} ms, total %{BASE16FLOAT:user_cpu_total} ms\tSystem CPU: own %{NUMBER:system_cpu_own:float} ms, total %{NUMBER:system_cpu_total:float} ms\tHeap Bytes: own %{BASE16FLOAT:heap_bytes_own} By, total %{BASE16FLOAT:heap_bytes_total} By\tBlocked count: own %{NUMBER:blocked_count_own:int}, total %{NUMBER:blocked_count_total:int}\tBlocked time: own %{NUMBER:blocked_timet_own:int} ms, total %{NUMBER:blocked_time_total:int} ms\tWait count: own %{NUMBER:wait_count_own:int}, total %{NUMBER:wait_count_total:int}\tWait time: own %{NUMBER:wait_time_own:int} ms, total %{NUMBER:wait_time_total:int} ms\tDB time: own %{NUMBER:db_time_own:int} ms, total %{NUMBER:db_time_total:int} ms\tDB count: own %{NUMBER:db_count_own:int}, total %{NUMBER:db_count_total:int}\tDB lread: own %{NUMBER:db_lread_own:int}, total %{NUMBER:db_lread_total:int}\tDB pread: own %{NUMBER:db_pread_own:int}, total %{NUMBER:db_pread_total:int}\tDB CPU time: own %{NUMBER:cpu_time_own:int} ms, total %{NUMBER:cpu_time_total:int} ms\tDB in bytes: own %{NUMBER:db_in_bytes_own:int} By, total %{NUMBER:db_in_bytes_total:int} By\tDB out bytes: own %{NUMBER:db_out_bytes_own:int} By, total %{NUMBER:db_out_bytes_total:int} By" } 
        }
      } else if "byte, total" in [message] {
        grok { 
          match => { "message" => "(\|\| %{DATA}\t|message\=Top\t)(%{WORD:controller})?(:|\t)(%{WORD:action})?\t%{GREEDYDATA}Elapsed time: own %{BASE16FLOAT:elapsed_time_own} ms, total %{BASE16FLOAT:elapsed_time_total} ms\tTotal CPU: own %{BASE16FLOAT:cpu_own} ms, total %{BASE16FLOAT:cpu_total} ms\tUser CPU: own %{BASE16FLOAT:user_cpu_own} ms, total %{BASE16FLOAT:user_cpu_total} ms\tSystem CPU: own %{NUMBER:system_cpu_own:float} ms, total %{NUMBER:system_cpu_total:float} ms\tHeap Bytes: own %{BASE16FLOAT:heap_bytes_own} byte, total %{BASE16FLOAT:heap_bytes_total} byte\tBlocked count: own %{NUMBER:blocked_count_own:int} one, total %{NUMBER:blocked_count_total:int} one\tBlocked time: own %{NUMBER:blocked_timet_own:int} ms, total %{NUMBER:blocked_time_total:int} ms\tWait count: own %{NUMBER:wait_count_own:int} one, total %{NUMBER:wait_count_total:int} one\tWait time: own %{NUMBER:wait_time_own:int} ms, total %{NUMBER:wait_time_total:int} ms\tDB time: own %{NUMBER:db_time_own:int} ms, total %{NUMBER:db_time_total:int} ms\tDB count: own %{NUMBER:db_count_own:int} one, total %{NUMBER:db_count_total:int} one\tDB lread: own %{NUMBER:db_lread_own:int} one, total %{NUMBER:db_lread_total:int} one\tDB pread: own %{NUMBER:db_pread_own:int} one, total %{NUMBER:db_pread_total:int} one\tDB CPU time: own %{NUMBER:cpu_time_own:int} ms, total %{NUMBER:cpu_time_total:int} ms\tDB in bytes: own %{NUMBER:db_in_bytes_own:int} byte, total %{NUMBER:db_in_bytes_total:int} byte\tDB out bytes: own %{NUMBER:db_out_bytes_own:int} byte, total %{NUMBER:db_out_bytes_total:int} byte" } 
        }
      }
    }
    if "indexing=" in [message] {
      grok {
        match => { "message" => "\[index=%{DATA:document_id}, operation=(%{WORD:operation})?, indexing=(%{NUMBER:indexing_count:float})?, uris=(%{NUMBER:uri_count:float})?\]"}
      }
      mutate {
        add_tag => [ "indexer-metrics" ]
      }
      if [indexing_count] {
        ruby {
          code => "event.set('indexRate',(event.get('indexing_count')/event.get('uri_count')))"
        }
      }
    }
    else if "resolving=" in [message] {
      grok {
        match => { "message" => "\[type=(%{WORD:resolver_type})?, index=%{DATA:resolver_id}, resolving=(%{NUMBER:resolving_count:int})?\]"}
      }
      mutate {
        add_tag => [ "indexer-metrics" ]
      }
    }
    else if "Indexing request queued for" in [message] {
      grok {
        match => { "message" => "Indexing request queued for: (%{NUMBER:queued_time:float})?ms. Entered the queue at \(entityTimestamp\): (%{NUMBER:entity_timestamp:int})?. URIs in the message: (%{NUMBER:uri_count:int})?."}
      }
      mutate {
        add_tag => [ "indexer-metrics" ]
      }
      if [queued_time] {
        ruby {
          code => "event.set('qDelayInSecs',(event.get('queued_time')/1000).round(5))"
        }
        ruby {
          code => "event.set('qDelayInMins',(event.get('queued_time')/(1000 * 60)).round(6))"
        }
      }
    }
  }
  else if [fields][source] == "indexer-verify" {
    grok {
      match => { "message" => "^\[%{GREEDYDATA:message_time_stamp} %{LOGLEVEL:log_level}( )?\]"}
    }
    if "Sending Nagios status" in [message] {
      grok {
        match => { "message" => "Index Verifier scanned (%{NUMBER:project_scanned:int})? projects, (%{NUMBER:entities_checked:int})? entities checked, (%{NUMBER:error_found:int})? errors found, took (%{NUMBER:took_hours:int})?:(%{NUMBER:took_minutes:int})?:(%{NUMBER:took_seconds:int})? and completed"}
      }
    }
  }
  else if [fields][source] == "indexer-router-errors" {
    grok {
      match => { "message" => "^\[%{GREEDYDATA:message_time_stamp} %{LOGLEVEL:log_level}\]\["}
    }
    if "ageListenerContainer" in [message] {
      grok {
        match => { "message" => "currentAttempts=(%{NUMBER:current_attempts:int})?"}
      }
    }
  }
  else if [fields][source] == "bim-application" {
    grok {
      match => { "message" => '^%{TIMESTAMP_ISO8601:message_time_stamp} \[(%{DATA:trace_id})?\] \[(%{DATA:user_agent})?\|%{DATA:proxy_agent}\] \[%{DATA:jvm_process_name}\] \[(%{NUMBER:user_id:int})?\] \[(%{NUMBER:project_id:int})?\] \[%{DATA:thread_id}\] %{LOGLEVEL:log_level}( )? %{DATA:logger} -'}
    }
    if "ExternalProcessLauncher" in [message] {
      grok {
        match => { "message" => "{bim.task.uniqueModelFileId=%{DATA:unique_model_file_id}, bim.task.aconexProjectId=(%{NUMBER:project_id:int})?}, springBeanName='%{WORD:spring_bean_name}'}"}
      }
    }
    else if "c.a.b.b.t.s.TaskInstance" in [message] {
      grok {
        match => { "message" => "task\[(%{NUMBER:task_id:int})?\]"}
      }
    }
    else if "server.RequestLog" in [message] {
      grok {
        match => { "message" => '"%{WORD:http_method} %{DATA:http_endpoint} %{DATA:http_protocol_version}" %{NUMBER:http_status_code} %{NUMBER:response_length:int}  %{NUMBER:response_time_ms:int}'}
      }
    }
    else if "TaskInstanceAssigner" in [message] {
      grok {
        match => { "message" => "Assigned (%{NUMBER:assigned_tasks:int})?, skipped (%{NUMBER:skipped_tasks:int})? tasks"}
      }
    }
    else if "ModelAnalysisProcessor" in [message] {
      grok {
        match => { "message" => "model %{GREEDYDATA:unique_model_file_id}"}
      }
    }
    else if "PooledDataSourceHealthCheck" in [message] {
      grok {
        match => { "message" => "dataSourceName=(%{WORD:data_source})?, numConnectionsAllUsers=%{NUMBER:connections_count:int}, numBusyConnectionsAllUsers=%{NUMBER:busy_connections_count:int}, numIdleConnectionsAllUsers=%{NUMBER:idle_connections_count:int}, numUnclosedOrphanedConnectionsAllUsers=%{NUMBER:unclosed_orphaned_connections_count:int}"}
      }
    }
    else if "JettyThreadPoolHealthCheck" in [message] {
      grok {
        match => { "message" => "busyThreads=%{NUMBER:threads_count:int}, threads=%{NUMBER:busy_threads_count:int}, maxThreads=%{NUMBER:max_threads:int}, queueSize=%{NUMBER:queue_size:int}"}
      }
    }
  }
  else if [fields][source] == "mail-composition" {
    grok {
      match => { "message" => '^%{TIMESTAMP_ISO8601:message_time_stamp} '}
    }
    if "parfait.timing.LoggerSink" in [message] {
      grok {
        match => { "message" => "Top#011%{DATA:controller}:%{WORD:action}#011%{GREEDYDATA}Elapsed time: own %{BASE16FLOAT:elapsed_time_own} ns, total %{BASE16FLOAT:elapsed_time_total} ns#011Total CPU: own %{BASE16FLOAT:cpu_own} ns, total %{BASE16FLOAT:cpu_total} ns#011User CPU: own %{BASE16FLOAT:user_cpu_own} ns, total %{BASE16FLOAT:user_cpu_total} ns#011System CPU: own %{NUMBER:system_cpu_own:float} ns, total %{NUMBER:system_cpu_total:float} ns#011Heap Bytes: own %{BASE16FLOAT:heap_bytes_own} By, total %{BASE16FLOAT:heap_bytes_total} By%{DATA}Database call count: own %{NUMBER:db_call_own:int}, total %{NUMBER:db_call_total:int}#011Database execution time: own %{NUMBER:db_exec_time_own:int} ms, total %{NUMBER:db_exec_time_total:int} ms"}
      }
    }
  }
  else if [fields][source] == "sso-audit" {
    grok { 
      match => { "message" => "^%{TIMESTAMP_ISO8601:message_time_stamp}\| tid:%{GREEDYDATA:tid}\| %{GREEDYDATA:auth_type}\| %{GREEDYDATA:user}\| %{GREEDYDATA:ip_address} \| %{GREEDYDATA:something}\| %{GREEDYDATA:application}\| %{GREEDYDATA:auth_method}\| %{GREEDYDATA:server}\| %{GREEDYDATA:auth_mode}\| %{GREEDYDATA:auth_state}\| %{GREEDYDATA:auth_subject}\| %{GREEDYDATA}\| %{GREEDYDATA}" } 
    }
  }
  else if [fields][source] == "sso-console-requests" {
    grok { 
      match => { "message" => '%{GREEDYDATA:SourceIp} - %{GREEDYDATA}- \[%{GREEDYDATA:message_time_stamp} %{GREEDYDATA}\] \"%{GREEDYDATA:method} %{GREEDYDATA:url} %{GREEDYDATA:http_version}\" %{NUMBER:http_status_code} %{NUMBER:Bytes} \"%{GREEDYDATA:http_reffer}\" \"%{GREEDYDATA:user_agent}\"' } 
    }
  }
  else if [fields][source] == "sso-console-admin" {    
    grok { 
      match => { "message" => "^%{GREEDYDATA:message_time_stamp} %{GREEDYDATA} \| %{GREEDYDATA:user} \| %{GREEDYDATA:roles} \| %{GREEDYDATA:source_ip} \| %{GREEDYDATA:mode} \| %{GREEDYDATA:status} \|%{GREEDYDATA}\| %{GREEDYDATA:result}" } 
    }
  }
  else if [fields][source] == "sso-console-admin-api" {    
    grok { 
      match => { "message" => "^%{GREEDYDATA:message_time_stamp}\| %{GREEDYDATA:user}\| %{GREEDYDATA:auth_method}\| %{GREEDYDATA:source_ip}\| %{GREEDYDATA:method}\| %{GREEDYDATA:url}\| %{GREEDYDATA:http_response}" } 
    }
  }
  else if [fields][source] == "sso-console-server-log" {    
    grok { 
      match => { "message" => "^%{GREEDYDATA:message_time_stamp}  %{LOGLEVEL:log_level}  \[%{GREEDYDATA:logger}\] %{GREEDYDATA:log_message}" } 
    }
  }
  else if [fields][source] == "sso-console-init-log" {    
    grok { 
      match => { "message" => "^%{TIMESTAMP_ISO8601:message_time_stamp} %{GREEDYDATA:log_message}" } 
    }
  }
  else if [fields][source] == "sso-requests" {
    grok { 
      match => { "message" => '%{GREEDYDATA:source_ip} - %{GREEDYDATA}- \[%{GREEDYDATA:message_time_stamp} %{GREEDYDATA}\] \"%{GREEDYDATA:method} %{GREEDYDATA:url} %{GREEDYDATA:http_version}\" %{NUMBER:http_status_code} %{NUMBER:bytes}' } 
    }
  }
  else if [fields][source] == "sso-init-log" {    
    grok { 
      match => { "message" => "^%{TIMESTAMP_ISO8601:message_time_stamp} %{GREEDYDATA:log_message}" } 
    }
  }
  else if [fields][source] == "sso-server-log" {    
    grok { 
      match => { "message" => "^%{GREEDYDATA:message_time_stamp}\s(tid:%{GREEDYDATA:thread_id})? %{LOGLEVEL:log_level}\s{1,2}\[%{GREEDYDATA:logger}\] %{GREEDYDATA:log_message}" } 
    }
    if "(ref#" in [message] {
      grok { 
        match => { "message" => "\(ref%{GREEDYDATA:error_reference}?\):" } 
      }
    }
    if "(reference#" in [message] {
      grok { 
        match => { "message" => "\(reference\# %{DATA:error_reference}?\)" } 
      }
    }   
  }
  else if [fields][source] == "consul-logs" {
    if "==> " in [message] {

    }
    else {
      grok { 
        match => { "message" => "\s+%{GREEDYDATA:message_time_stamp} \[%{LOGLEVEL:level}\] %{WORD:component}: %{GREEDYDATA:log_message}" } 
      }
    }
  }
  else if [fields][source] == "field-comments" {
    grok {
      match => { "message" => "%{LOGLEVEL:log_level}   \[%{DATA:thread_id}\]\[%{DATA:logger}\]\[%{DATA:message_time_stamp}\]\["}
    }
    mutate {
      add_tag => [ "field-comments" ]
    }
  }
  else if [fields][source] == "field-reports" {
    grok {
      match => { "message" => "%{LOGLEVEL:log_level}   \[%{DATA:thread_id}\]\[%{DATA:logger}\]\[%{DATA:message_time_stamp}\]\["}
    }
    mutate {
      add_tag => [ "field-reports" ]
    }
  }
  else if [fields][source] == "server-logs" {
    if [source] == "/var/log/messages" { 
      if "mail-composition-svc" in [message] {
        grok {
          match => { "message" => "^%{TIMESTAMP_ISO8601:message_time_stamp} %{DATA} %{DATA:service}\[(%{DATA:request_id})?\] \[%{IP:ip_address}\] \[%{DATA:url}\] \[(%{NUMBER:project_id:int})?\] \[(%{NUMBER:user_id:int})?\] \[(%{DATA:thread_id})?\] %{LOGLEVEL:log_level}"}
        }
        mutate {
          add_tag => [ "mail-composition" ]
        }
      } else {
        grok {
          match => { "message" => "^%{TIMESTAMP_ISO8601:message_time_stamp} %{DATA} %{DATA:service}(\[%{NUMBER:pid:int}\]|:|\[%{NUMBER:pid:int}\]:)? %{GREEDYDATA}"}
        }
      }
      
      if "postfix/" in [message] {
        mutate {
          add_tag => [ "babylon-emailer-postfix" ]
        }
        if "(queue active)" in [message] {
          grok {
            match => { "message" => "size=%{NUMBER:size:int}"}
          }
        }
        if "message-id=" in [message] {
          grok {
            match => { "message" => ": %{DATA:postfix_message_id}: message-id=<%{DATA:message_id}>"}
          }
        }     
      }
      else if "docker/linking-service" in [message] {
        grok {
          match => { "message" => "- %{LOGLEVEL:log_level}%{DATA}\[%{DATA:thread_id}\]"}
        }
        mutate {
          add_tag => [ "linking-service" ]
        }
      }
      else if "babylon-elasticsearch-verify" in [message] {
        mutate {
          add_tag => [ "esverifier-syslog" ]
        }
      }
      else if "document-relationship-service" in [message] {
        mutate {
          add_tag => [ "related-items-serivce" ]
        }
        if "[GC" in [message] {
          grok {
            match => { "message" => ": \[%{DATA:gc_type} \(%{DATA:gc_cause}\)%{DATA}\[%{WORD:gc_collector}: %{NUMBER:young_generation_before:int}K\-\>%{NUMBER:young_generation_after:int}K\(%{NUMBER:young_generation_capacity:int}K\)\] %{NUMBER:heap_before:int}K\-\>%{NUMBER:heap_after:int}K\(%{NUMBER:heap_capacity:int}K\), %{NUMBER:collection_time:float} secs\] \[Times: user=%{NUMBER:cpu_time:float} sys=%{NUMBER:system_time:float}, real=%{NUMBER:clock_time:float} secs\]"}
          }
        } else {
          grok {
            match => { "message" => "-( )?%{LOGLEVEL:log_level}%{DATA}\[%{GREEDYDATA:thread_id}\] %{DATA:logger} %{DATA}:%{GREEDYDATA:log_message}"}
          }
        }
        if [logger] == "RelatedItemsInterceptor" {
          grok {
            match => { "message" => "method=%{WORD:http_method},uri=\\\/project\\\/%{NUMBER:project_id:int}\\\/(has-relationships|copy-relationships),status=%{NUMBER:http_status_code},et=%{NUMBER:et_time:int}ms."}
          }
        } else if [logger] == "c.a.r.links.service.LinkingService" {
          grok {
            match => { "message" => "Returned links for %{GREEDYDATA:params}."}
          }
          if [params] {
            kv {
              source => "params"
              field_split_pattern => ","
            }
            mutate {
              convert => ["size", "integer"]
            }
          }
        } else if [logger] == "c.a.relateditems.service.BabylonService" or [logger] == "c.a.r.clients.babylon.BabylonApiClient" {
          grok {
            match => { "message" => "details pid=%{NUMBER:project_id:int},docsize=%{NUMBER:doc_size:int}"}
          }
        }
      }
      else if "docker/document-relationship-api" in [message] {
        mutate {
          add_tag => [ "related-items-api" ]
        }
      }
      else if "field-comments[" in [message] {
        grok {
          match => { "message" => ": %{LOGLEVEL:log_level}   \[%{DATA:thread_id}\]\[%{DATA:logger}\]"}
        }
        mutate {
          add_tag => [ "field-comments" ]
        }
      }
      else if "docker/field-reports" in [message] {
        grok {
          match => { "message" => ": %{LOGLEVEL:log_level}   \[%{DATA:thread_id}\]\[%{DATA:logger}\]"}
        }
        mutate {
          add_tag => [ "field-reports" ]
        }
      }
      else if "docker/field-checklists" in [message] {
        grok {
          match => { "message" => "\[\] \[\] \[%{DATA:thread_id}\] %{LOGLEVEL:log_level} "}
        }
        mutate {
          add_tag => [ "field-checklists" ]
        }
      }
      else if "zip-download-service[" in [message]{
        grok { 
          match => { "message" => ": %{DATA} \[%{DATA:request_id}\] \[%{DATA:thread_id}\] %{LOGLEVEL:log_level} ?( )%{DATA:logging_class} - %{GREEDYDATA:log_message}" } 
        }
        mutate {
          add_tag => [ "zip-download-service" ]
        }
        if [log_level] == "ERROR" {
          if "JwtParsingException" in [message] {
            mutate {
              add_field => { "zip_download_error_type" => "jwt_error" }
            }
          }
          else if "ClientAbortException" in [message] {
            mutate {
              add_field => { "zip_download_error_type" => "cae_error" }
            }
          }
        }
        if "Streamed zip entry" in [message] {
          mutate {
            add_field => { "zip_download_type" => "entry_complete" }
          }
          grok {
            match => { "message" => "Streamed zip entry, fileId: %{NUMBER:file_id:int}, size: %{NUMBER:file_size:float} MB, effectiveTransferRate: %{NUMBER:transfer_rate:float} MB/s"}
          }
          if [file_size] {
            ruby {
              code => "event.set('file_size_gb',(event.get('file_size')/1024).round(6))"
            }
          }
        }
        else if "Start handling request" in [message] {
          mutate {
            add_field => { "zip_download_type" => "start_handling" }
          }
          grok {
            match => { "message" => "forwarded: %{IP:ip1}, %{IP:ip2}, %{IP:ip3}, uid: %{NUMBER:user_id:int}, pid: %{NUMBER:project_id:int}, oid: %{NUMBER:org_id:int}, originalBabylonRequestId: %{GREEDYDATA:orginal_babylon_request_id}"}
          }
          if [ip1] {
            geoip {
              source => "ip1"
            }
          }
        }
        else if "Finished handling request" in [message] {
          mutate {
            add_field => { "zip_download_type" => "finished_handling" }
          }
          grok {
            match => { "message" => "forwarded: %{IP:ip1}, %{IP:ip2}, %{IP:ip3},( %{IP:ip4},)? uid: %{NUMBER:user_id:int}, pid: %{NUMBER:project_id:int}, oid: %{NUMBER:org_id:int}, originalBabylonRequestId: %{GREEDYDATA:orginal_babylon_request_id}, fileNums: %{NUMBER:file_number:int}, totalSize: %{NUMBER:total_size:float} MB, effectiveTransferRate: %{NUMBER:transfer_rate:float} MB/s, responseStatus: %{NUMBER:http_status_code},%{GREEDYDATA}elapsedTimeMS: %{NUMBER:elapsed_time_micros:int}"}
          }
          if [ip1] {
            geoip {
              source => "ip1"
            }
          }
          if [elapsed_time_micros] {
            ruby {
              code => "event.set('elapsed_time_sec',(event.get('elapsed_time_micros')/1000).round(3))"
            }
            ruby {
              code => "event.set('elapsed_time_min',(event.get('elapsed_time_micros')/(1000 * 60)).round(4))"
            }
          }
        }
        else if "Skipping file" in [message] {
          mutate {
            add_field => { "zip_download_type" => "unreadable_file"}
          }
          grok {
            match => { "message" => "filesystem, fileId: %{NUMBER:file_id:int}, path: /nas/%{WORD:instance_legacy_name}/filestore%{NUMBER:file_store_id:int}/"}
          }
        }
      }
      else if "redliner-ui" in [message] or "pdf-merge-api" in [message] or "redliner-service" in [message] or "pdftron-webviewer" in [message] {
        mutate {
          add_tag => [ "viewer" ]
        }
        if '"reviewId"' in [message] {
          grok {
            match => { "message" => '"reviewId":"(%{NUMBER:review_id:int})?",'}
          }
        }
        if "docker/redliner-ui" in [message] {
          if "[error]" in [message] {
            grok {
              match => { "message" => 'client: (%{IP:client_ip})?, server: (%{DATA:server})?, request: "%{WORD:method} %{DATA:url} %{DATA:protocol}", host: "(%{DATA:host})?", referrer: "(%{DATA:referrer})?"'}
            }
          }
        }
        else if "pdf-merge-api" in [message] {
          grok {
            match => { "message" => ": INFO   \[(%{DATA})?\]\[(%{WORD:logger})?\]"}
          }
          if "Elapsed time" in [message] {
            grok {
              match => { "message" => "(Top|Nested \(1\))#011%{DATA:controller}:%{WORD:action}#011%{GREEDYDATA}Elapsed time: own %{BASE16FLOAT:elapsed_time_own} ns, total %{BASE16FLOAT:elapsed_time_total} ns#011Total CPU: own %{BASE16FLOAT:cpu_own} ns, total %{BASE16FLOAT:cpu_total} ns#011User CPU: own %{BASE16FLOAT:user_cpu_own} ns, total %{BASE16FLOAT:user_cpu_total} ns#011System CPU: own %{NUMBER:system_cpu_own:float} ns, total %{NUMBER:system_cpu_total:float} ns#011Heap Bytes: own %{BASE16FLOAT:heap_bytes_own} byte, total %{BASE16FLOAT:heap_bytes_total} byte"}
            }
          }
        }
        else if "redliner-service" in [message] {
          if "INFO" in [message] {
            grok {
              match => { "message" => ": INFO   \[(%{DATA})?\]\[(%{WORD:logger})?\]"}
            }
          }
        }
        else if "pdftron-webviewer-loadbalancer" in [message] {
          grok {
            match => { "message" => '"%{WORD:method} %{DATA:url} %{DATA:protocol}"'}
          }
          if "localnodes nodes_haproxid/<NOSRV>" in [message] {
            grok {
              match => { "message" => "localnodes nodes_haproxid/<NOSRV> %{DATA} %{NUMBER:http_status_code}"}
            }
          }
        }
        else if "document/review/index.html?requestProjectId" in [message] {
          grok {
            match => { "message" => "requestProjectId=(%{NUMBER:project_id:int})?&workFlowBatchId=(%{NUMBER:workflow_batch_id:int})?&stepId=(%{NUMBER:step_id:int})?&_action=(%{WORD:action})?&viewName=%{DATA:view_name}&%{DATA}taskId=(%{NUMBER:task_id:int})?"}
          }
        }
      }
      else if "document-review" in [message] {
        mutate {
          add_tag => [ "document-review" ]
        }
        if '"fileId"' in [message] {
          grok {
            match => { "message" => '"fileId":"(%{NUMBER:file_id:int})?"'}
          }
        }
        if '"totalTimeTaken"' in [message] {
          grok {
            match => { "message" => '"totalTimeTaken":(%{NUMBER:time_taken:int})?'}
          }
        }
        if '"pageCount"' in [message] {
          grok {
            match => { "message" => '"pageCount":(%{NUMBER:page_count:int})?'}
          }
        }
        if "reviewId=" in [message] {
          grok {
            match => { "message" => "reviewId=(%{NUMBER:review_id:int})?"}
          }
        }
        if '"service":"Redliner UI"' in [message] {
          mutate {
            add_field  => { "doc_review_service" => "Redliner UI" }
          }
          if 'LogAggregator[{"userId"' in [message] {
            grok {
              match => { "message" => '\[{"userId":"(%{NUMBER:user_id:int})?","projectId":"(%{NUMBER:project_id:int})?","tenant":"(%{DATA:tenant})?",%{DATA},"key":"%{DATA:key}",'}
            }
          } 
          else if 'LogAggregator[{"projectId"' in [message] {
            grok {
              match => { "message" => '\[{"projectId":(%{NUMBER:project_id:int})?,"userId":(%{NUMBER:user_id:int})?,"tenant":"(%{DATA:tenant})?",%{DATA},"key":"%{DATA:key}",'}
            }
          }
        }
        else if 'fileDetails' in [message] {
          grok {
            match => { "message" => '\[{"projectId":(%{NUMBER:project_id:int})?,"userId":(%{NUMBER:user_id:int})?,%{DATA}"workFlowBatchId":"(%{NUMBER:workflow_batch_id:int})?","initialReviewId":"(%{NUMBER:initial_review_id:int})?","stepId":"(%{NUMBER:step_id:int})?","key":"%{DATA:key}","reviewId":"(%{NUMBER:review_id:int})?","stepName":"(%{DATA:step_name})","fileDetails":{"fileId":"(%{NUMBER:file_id:int})?","fileType":"(%{WORD:file_type})?","fileName":"%{DATA:file_name},"frozen":%{DATA:frozen},"fileSize":"(%{NUMBER:file_size:int})?"},"timeTaken":(%{NUMBER:time_taken:int})?,"type":"%{DATA}","service":"(%{DATA:service})?"}\]'}
          }
        }
        else if "document/review/index.html?_action" in [message] {
          grok {
            match => { "message" => "action=(%{WORD:action})?&viewName=%{DATA:view_name}&workFlowBatchId=(%{NUMBER:workflow_batch_id:int})?&stepId=(%{NUMBER:step_id:int})?&projectId=(%{NUMBER:project_id:int})?&returnURL=%{DATA:return_url}&%{GREEDYDATA}"}
          }
        }
        else if "document/review/index.html?requestProjectId" in [message] {
          grok {
            match => { "message" => "requestProjectId=(%{NUMBER:project_id:int})?&workFlowBatchId=(%{NUMBER:workflow_batch_id:int})?&stepId=(%{NUMBER:step_id:int})?&_action=(%{WORD:action})?&viewName=%{DATA:view_name}&%{DATA}taskId=(%{NUMBER:task_id:int})?"}
          }
        }
        else if "moduleKey=SETUP&projectId" in [message] {
          grok {
            match => { "message" => 'projectId=(%{NUMBER:projet_id:int})?&organizationId=(%{NUMBER:org_id:int})?"'}
          }
        }
      }
      else if "docker/reviews[" in [message] {
        mutate {
          add_tag => [ "reviews" ]
        }
        grok {
          match => { "message" => "docker/reviews\[%{NUMBER:pid:int}\]%{DATA}\[(%{GREEDYDATA:request_id})?\] \[(%{GREEDYDATA:ips})?\] \[(%{GREEDYDATA:url})?\] \[(%{NUMBER:xid})?\] \[(%{NUMBER:yid})?\] \[(%{GREEDYDATA:thread_id})?\] %{LOGLEVEL:log_level}"}
        }
        if "Elapsed time" in [message] {
          grok {
            match => { "message" => "Top#011%{DATA:controller}:%{WORD:action}#011%{GREEDYDATA}Elapsed time: own %{BASE16FLOAT:elapsed_time_own} ns, total %{BASE16FLOAT:elapsed_time_total} ns#011Total CPU: own %{BASE16FLOAT:cpu_own} ns, total %{BASE16FLOAT:cpu_total} ns#011User CPU: own %{BASE16FLOAT:user_cpu_own} ns, total %{BASE16FLOAT:user_cpu_total} ns#011System CPU: own %{NUMBER:system_cpu_own:float} ns, total %{NUMBER:system_cpu_total:float} ns#011Heap Bytes: own %{BASE16FLOAT:heap_bytes_own} byte, total %{BASE16FLOAT:heap_bytes_total} byte"}
          }
        }
      }
      else if "docker/reviews-lb[" in [message] {
        mutate {
          add_tag => [ "reviews" ]
        }
      }
      else if "grp-mgmt" in [message] {
        mutate {
          add_tag => [ "group-management" ]
        }
        if "c.c.parfait.timing.LoggerSink" in [message] {
          grok {
            match => { "message" => "Top#011%{DATA:controller}:%{WORD:action}#011%{GREEDYDATA}Elapsed time: own %{BASE16FLOAT:elapsed_time_own} ns, total %{BASE16FLOAT:elapsed_time_total} ns#011Total CPU: own %{BASE16FLOAT:cpu_own} ns, total %{BASE16FLOAT:cpu_total} ns#011User CPU: own %{BASE16FLOAT:user_cpu_own} ns, total %{BASE16FLOAT:user_cpu_total} ns#011System CPU: own %{NUMBER:system_cpu_own:float} ns, total %{NUMBER:system_cpu_total:float} ns#011Heap Bytes: own %{BASE16FLOAT:heap_bytes_own} By, total %{BASE16FLOAT:heap_bytes_total} By%{DATA}Database call count: own %{NUMBER:db_call_own:int}, total %{NUMBER:db_call_total:int}#011Database execution time: own %{NUMBER:db_exec_time_own:int} ms, total %{NUMBER:db_exec_time_total:int} ms"}
          }
        }
      }
      else if "mail-routing" in [message] {
        mutate {
          add_tag => [ "mail-routing" ]
        }
        if "http-in servers" in [message] {
          grok {
            match => { "message" => '"%{WORD:method} /mail-routing/projects/%{NUMBER:project_id:int}/mail-types/%{NUMBER:mail_type:int}/'}
          }
        }
        else if "[/mail-routing/projects" in [message] {
          grok {
            match => { "message" => "\[/mail-routing/projects/%{NUMBER:project_id:int}/mail-types/%{NUMBER:mail_type:int}/"}
          }
        }
      }
      else if "pkg-mgmt" in [message] {
        mutate {
          add_tag => [ "package-management" ]
        }
        
        if [service] == "pkg-mgmt-api" {
          grok {
            match => { "message" => ' \[(%{DATA:request_id})?\] \[(%{DATA:endpoint})?\] \[(%{NUMBER:project_id:int})?\] \[(%{NUMBER:user_id:int})?\] '}
          }
          if "Exception" in [message] {
            grok { 
              match => { "message" => "%{GREEDYDATA}(\n|\]) %{DATA:exception_type}Exception" } 
            }
          }
        } else if [service] == "docker/pkg-mgmt-svc-lb" {
          if "mailId=" in [message] {
            grok {
              match => { "message" => 'mailId=%{NUMBER:mail_id:int}'}
            }
          }
          if "package-management/private/projects" in [message] {
            grok {
              match => { "message" => '"%{WORD:method} \/package-management\/private\/projects\/%{NUMBER:project_id:int}%{DATA} %{DATA:protocol}"'}
            }
          }
        } else if [service] == "pkg-mgmt-ui" or [service] == "pkg-mgmt-svc" {
          if "Exception" in [message] {
            grok { 
              match => { "message" => " \[(%{DATA:request_id})?\] \[(%{DATA:endpoint})?\] \[(%{NUMBER:project_id:int})?\] \[(%{NUMBER:user_id:int})?\] %{DATA:exception_type}Exception" } 
            }
          } else {
            grok {
              match => { "message" => ' \[(%{DATA:request_id})?\] \[(%{DATA:endpoint})?\] \[(%{NUMBER:project_id:int})?\] \[(%{NUMBER:user_id:int})?\] :AUDIT: %{GREEDYDATA:params}'}
            }
            if [params] {
              kv {
                source => "params"
                field_split_pattern => ", "
                remove_char_value => "\[\]\{\}"
              }
            }
          }
        }
      }
      else if "docker/preview-service-web" in [message] {
        grok {
          match => { "message" => ':%{DATA} %{LOGLEVEL:log_level}'}
        }
        mutate {
          add_tag => [ "preview-service-web" ]
        }
        if "service.BabylonEventLogService" in [message] {
          grok {
            match => { "message" => 'Preview request from user (%{NUMBER:user_id:int})?, project (%{NUMBER:project_id:int})?, document (%{NUMBER:document_id:int})?'}
          }
        }
        else if "parfait.timing.LoggerSink" in [message] {
          grok {
            match => { "message" => 'Top#011%{DATA:controller}:%{WORD:action}#011%{DATA}Elapsed time: own %{BASE16FLOAT:elapsed_time_own} ns, total %{BASE16FLOAT:elapsed_time_total} ns#011Total CPU: own %{BASE16FLOAT:cpu_own} ns, total %{BASE16FLOAT:cpu_total} ns#011User CPU: own %{BASE16FLOAT:user_cpu_own} ns, total %{BASE16FLOAT:user_cpu_total} ns#011System CPU: own %{NUMBER:system_cpu_own:float} ns, total %{NUMBER:system_cpu_total:float} ns#011Heap Bytes: own %{BASE16FLOAT:heap_bytes_own} byte, total %{BASE16FLOAT:heap_bytes_total} byte#011Blocked count: own %{NUMBER:blocked_count_own:int} one, total %{NUMBER:blocked_count_total:int} one#011Blocked time: own %{NUMBER:blocked_timet_own:int} ms, total %{NUMBER:blocked_time_total:int} ms#011Wait count: own %{NUMBER:wait_count_own:int} one, total %{NUMBER:wait_count_total:int} one#011Wait time: own %{NUMBER:wait_time_own:int} ms, total %{NUMBER:wait_time_total:int} ms'}
          }
        }
      }
      else if "preview-service-converter" in [message] {
        mutate {
          add_tag => [ "preview-service-converter" ]
        }
      }
      else if "docker/project-provisioning-service" in [message] { 
        mutate {
          add_tag => [ "project-provisioning-service" ]
        }   
        if "c.a.p.p.settings.BabylonSettingsClient" in [message] {
          grok {
            match => { "message" => 'Org-ID - %{NUMBER:org_id:int} : USER-ID - %{NUMBER:user_id:int} : Source Project-ID - %{NUMBER:source_project_id:int} : Target Project-ID - %{NUMBER:target_project_id:int} : UUID - %{DATA:app_uuid} -'}
          }
        }    
      }
    }
  }
  else if [fields][source] == "server-mail-logs" {
    if "queue active" in [message] {
      grok {
        match => { "message" => "size=(%{NUMBER:size:int})?"}
      }
    }
    else if "delivery temporarily suspended" in [message] {
      grok {
        match => { "message" => "delay=(%{NUMBER:delay:int})?"}
      }
    }
  }
  else if [fields][source] == "puppet-logs" {
    if "Puppet" in [message] {
      grok {
        match => { "message" => '^%{DATA:message_time_stamp} Puppet \(%{LOGLEVEL:log_level}\): %{GREEDYDATA:log_message}'}
      }
    }
    else if "Stage[main]" in [message] {
      grok {
        match => { "message" => '^%{GREEDYDATA:message_time_stamp} %{DATA:controller} \(%{LOGLEVEL:log_level}\): %{GREEDYDATA:log_message}'}
      }
    }
    if "change from absent to present failed" in [message] {
      mutate {
        add_field => { "error_type" => "absent_to_present_failed" }
      }
    }
    else if "rpmdb open failed" in [message] {
      mutate {
        add_field => { "error_type" => "rpmdb_open_failed" }
      }
    }
    else if "cannot open Packages database" in [message] {
      mutate {
        add_field => { "error_type" => "packagedb_open_failed" }
      }
    }
  }
  else if [fields][source] == "yum-logs" {
    grok {
      match => { "message" => '^%{GREEDYDATA:message_time_stamp} %{WORD:action}: %{GREEDYDATA:package}'}
    }
  }
  else if [fields][source] == "cost-api-logs" {
    grok {
      match => { "message" => '^%{TIMESTAMP_ISO8601:message_time_stamp} \[(%{IP})?\] \[(%{NUMBER:org_id:int})?\] \[(%{NUMBER:project_id:int})?\] \[(%{NUMBER:user_id:int})?\] \[(%{DATA:thread_id})?\] %{LOGLEVEL:log_level}'}
    }
    if "dw-" in [thread_id] {
      grok {
        match => { "message" => "\[dw-%{DATA} - %{WORD:http_method} %{DATA:http_url}\]"}
      }
    }
  }
  else if [fields][source] == "cost-api-request-logs" {
    grok {
      match => { "message" => '(%{IP:ip_address})? - - \[%{DATA:message_time_stamp}\] "%{WORD:http_method} %{DATA:url}(\?%{DATA:query_params})? %{DATA:http_version}" %{NUMBER:http_status_code}%{GREEDYDATA}" %{NUMBER:log_latency_ms:int}'}
    }
    if "/organizations/" in [url] {
      grok {
        match => { "message" => '/organizations/(%{NUMBER:org_id:int})?'}
      }
    }
    if "/projects/" in [url] {
      grok {
        match => { "message" => '/projects/(%{NUMBER:project:int})?'}
      }
    }
    ruby {
      code => "event.set('endpoint',(event.get('url').gsub(/\d+/, '{id}')))"
    }
  }
  else if [fields][source] == "cost-app-logs" {
    if "[dw-" in [message] {
      grok {
        match => { "message" => '^%{TIMESTAMP_ISO8601:message_time_stamp} %{DATA} \[dw-%{DATA} - %{WORD:http_method} %{DATA:http_url}\] %{LOGLEVEL:log_level}'}
      }
    }
  }
  else if [fields][source] == "cost-app-request-logs" {
    grok {
      match => { "message" => '(%{IP:ip_address})? - - \[%{DATA:message_time_stamp}\] "%{WORD:http_method} %{DATA:url}(\?%{DATA:query_params})? %{DATA:http_version}" %{NUMBER:http_status_code}%{GREEDYDATA}" %{NUMBER:log_latency_ms:int}'}
    }
    if "/organizations/" in [url] {
      grok {
        match => { "message" => '/organizations/%{NUMBER:org_id:int}'}
      }
    }
    if "/projects/" in [url] {
      grok {
        match => { "message" => '/projects/%{NUMBER:project:int}'}
      }
    }
    ruby {
      code => "event.set('endpoint',(event.get('url').gsub(/\d+/, '{id}')))"
    }
  }
  else if [fields][source] == "cost-api-out-logs" {    
    if [message] =~ "^\d{4}-" {
      grok {
        match => { "message" => '^%{TIMESTAMP_ISO8601:message_time_stamp} \[(%{IP})?\] \[(%{NUMBER:org_id:int})?\] \[(%{NUMBER:project_id:int})?\] \[(%{NUMBER:user_id:int})?\] \[(%{DATA:thread_id})?\] %{LOGLEVEL:log_level}'}
      }
    }    
  }
  else if [fields][source] == "ssl-request" {
    grok {
      match => { "message" => '^\[%{DATA:message_time_stamp}\] %{IP} (%{DATA:ssl_protocol}|-)? (%{DATA:ssl_cipher}|-)? "'}
    }
  }
  else if [fields][source] == "reporting-logs" {
    grok {
      match => { "message" => '^%{DATA:message_time_stamp} %{LOGLEVEL:log_level}  \[%{DATA:thread_id}\] \[%{NUMBER:org_id:int}\] \[%{NUMBER:user_id:int}\] \[%{DATA:java_class}\] - %{GREEDYDATA:log_message}'}
    }
  }
  else if [fields][source] == "custom-fields" or [fields][source] == "field-api" or [fields][source] == "field-trusted-api" {
    if "Vault responded with HTTP status code" in [message] {
      grok {
        match => { "message" => "Vault responded with HTTP status code: %{NUMBER:vault_http_status_code}"}
      }
    }
  }
  else if [fields][source] == "activemq" {
    grok {
      match => { "message" => "^%{TIMESTAMP_ISO8601:message_time_stamp} \| %{LOGLEVEL:log_level}  \| Transport Connection to: %{DATA:connection_failed_tcp} failed: %{DATA:exception_type} \|%{DATA}ActiveMQ Transport: %{GREEDYDATA:activemq_transport_tcp}"}
    }
  }
  else if [fields][source] == "activemq-wrapper" {
    grok {
      match => { "message" => "%{GREEDYDATA}\| %{DATA:message_time_stamp} \|  %{LOGLEVEL:log_level} \| Transport Connection to: %{DATA:connection_failed_tcp} failed: %{GREEDYDATA:exception_type}"}
    }
  }
    
  if "_grokparsefailure" not in [tags] {
    if [http_status_code] {
      if [http_status_code] =~ /2\d{2}/ {
        mutate {
          add_field => { "http_status_type" => "2xx" }
        }
      }
      else if [http_status_code] =~ /3\d{2}/ {
        mutate {
          add_field => { "http_status_type" => "3xx" }
        }
      }
      else if [http_status_code] =~ /4\d{2}/ {
        mutate {
          add_field => { "http_status_type" => "4xx" }
        }
      }else if [http_status_code] =~ /5\d{2}/ {
        mutate {
          add_field => { "http_status_type" => "5xx" }
        }
      }
    }
    if [elapsed_time_own] {
      ruby {
        code => "event.set('elapsed_time_own',(event.get('elapsed_time_own').to_f))"
      }
    }
    if [elapsed_time_total] {
      ruby {
        code => "event.set('elapsed_time_total',(event.get('elapsed_time_total').to_f))"
      }
    }
    if [cpu_own] {
      ruby {
      code => "event.set('cpu_own',(event.get('cpu_own').to_f))"
      }
    }
    if [cpu_total] {
      ruby {
        code => "event.set('cpu_total',(event.get('cpu_total').to_f))"
      }
    }
    if [user_cpu_own] {
      ruby {
        code => "event.set('user_cpu_own',(event.get('user_cpu_own').to_f))"
      }
    }
    if [user_cpu_total] {
      ruby {
        code => "event.set('user_cpu_total',(event.get('user_cpu_total').to_f))"
      }
    }
    if [heap_bytes_own] {
      ruby {
        code => "event.set('heap_bytes_own',(event.get('heap_bytes_own').to_f))"
      }
    }
    if [heap_bytes_total] {
      ruby {
        code => "event.set('heap_bytes_total',(event.get('heap_bytes_total').to_f))"
      }
    }
    if [db_in_bytes_own] {
      ruby {
        code => "event.set('db_in_bytes_own',(event.get('db_in_bytes_own').to_f))"
      }
    }
    if [db_in_bytes_total] {
      ruby {
        code => "event.set('db_in_bytes_total',(event.get('db_in_bytes_total').to_f))"
      }
    }
    if [db_out_bytes_own] {
      ruby {
        code => "event.set('db_out_bytes_own',(event.get('db_out_bytes_own').to_f))"
      }
    }
    if [db_out_bytes_total] {
      ruby {
        code => "event.set('db_out_bytes_total',(event.get('db_out_bytes_total').to_f))"
      }
    }
    date {
      tag_on_failure => ["date-processing-failed"]
      match => [ "message_time_stamp", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSSSSZZ", "yyyy-MM-dd'T'HH:mm:ssZZ", "yyyy-MM-dd'T'HH:mm:ss,SSSZZ", "yyyy-MM-dd HH:mm:ss,SSS", "dd/MMM/yyyy:HH:mm:ss", "dd/MMM/yyyy:HH:mm:ss Z", "dd/MMM/yyyy:HH:mm:ss.SSS", "yyyy/MM/dd HH:mm:ss", "EEE MMM dd HH:mm:ss Z yyyy", "MMM dd HH:mm:ss", "yyyy-MM-dd'T'HH:mm:ss,SSS Z","yyyy-MM-dd'T'HH:mm:ss Z","yyyy-MM-dd'T'HH:mm:ss ZZ", "yyyy-MM-dd HH:mm:ss"]
      target => "@timestamp"
    }
  }
}
 
output {
   
  stdout {
    codec => rubydebug
  }
 
  # Sending properly parsed log events to elasticsearch
  elasticsearch {
    hosts => ["localhost:9200"]
  }
}
